---
title: "Multi-level Pricing Model"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

```{r, message = FALSE, warning = FALSE}
library(rstan)
library(loo)
library(tidyverse)
library(here)
setwd(here())
```

```{r}
rstan_options(auto_write = TRUE) #cache model
options(mc.cores = parallel::detectCores()) #multiple cores for multiple chains
```

We'll be doing some 2, 3 and even 4-level models in Stan, then comparing them using the Loo package.

### The Data

```{r}
model_data <- read.csv("data/model_data.csv")
colnames(model_data) <- c("Price", "store_id", "UPC", "banner_id", "region_id")
```

The regressand is the price of an item. Regressors include the UPC of the item, the specific store, the supermarket brand, and the region.

```{r coding the data}
#level 1 n
N_obs = nrow(model_data)
#level 2 n
N_stores = length(unique(model_data$store_id))
#level 3 n
N_banners = length(unique(model_data$banner_id))
#level 4 n
N_regions = length(unique(model_data$region_id))

N_upc = length(unique(model_data$UPC))

#cluster ids
store_id = as.numeric(as.factor(model_data$store_id))
banner_id = as.numeric(as.factor(model_data$banner_id))
region_id = as.numeric(as.factor(model_data$region_id))
upc_id = as.numeric(as.factor(model_data$UPC))

## Create a vector of school IDs where j-th element gives school ID for class ID j
#upper_level_lookup <- unique(d[c("lower_id", "upper_id")])[,"upper_id"]
banner_level_lookup <- unique(model_data[c("store_id", "banner_id")])[,"banner_id"]
region_level_lookup <- unique(model_data[c("store_id", "region_id")])[,"region_id"]

#continuous outcome
Price = as.numeric(model_data$Price)
```

Consistent with Stan's best practices, we're going to dump the processed data into a separate file and clear our environment. Then, we'll read it back in.

```{r stan data dump}
stan_rdump(c("N_obs", "N_stores", "N_banners", "N_regions", "N_upc",
             "store_id", "banner_id", "region_id", "upc_id",
             "banner_level_lookup", "region_level_lookup",
             "Price"), file="data/stan_data_dump.R")

rm(banner_id); rm(banner_level_lookup); rm(N_banners); rm(N_obs); rm(N_regions);
rm(N_stores); rm(N_upc); rm(Price); rm(region_id); rm(store_id); rm(upc_id)
rm(model_data); rm(region_level_lookup)

data <- read_rdump("data/stan_data_dump.R") #import data
```

### Preview

We can see that the price, which is always positive, should be transformed. This makes sampling much faster. However, the log is highly skewed. A standization scaling works better. The scaling will be performed in Stan.

```{r}
qplot(data$Price)
qplot(log(data$Price))
qplot(scale(data$Price))
```


### Model 1- Single level model w/o Priors, Generated Quantities

We'll just model price as a function of UPC. 

```{r}
writeLines(readLines("models/1_single_level_no_prior_no_gen.stan"))
```

Next, we'll compile the model. This allows us to check for errors.

```{r}
m1_upc <- stanc(file = "models/1_single_level_no_prior_no_gen.stan") # Check Stan file
m1_upc <- stan_model(stanc_ret = m1_upc) # Compile Stan code
```

When running 4 chains in parallel, the time to execute is as long as the longest chain. 

```{r}
fit1_upc <- sampling(m1_upc, #use sampling function, rather than stan()
                warmup=1000, #recommended in Betancourt "RStan Workflow"
                iter=2000, #TOTAL iterations- first 1000 are warmup
                seed=1, #ensures reproducibility
                data=data, 
                chains = 4, #each chain has different initial condition which helps to find pathological neighborhood of posterior
                cores = getOption("mc.cores", 1L),
                verbose = TRUE)
rm(m1_upc)
```

```{r}
list_of_draws <- rstan::extract(fit1_upc)
print(names(list_of_draws))
print(fit1_upc, c("beta_0", "beta_1")) 
```

### Model 2- Single level model w/ Priors, w/o Generated Quantities

We'll add some priors. 

```{r}
writeLines(readLines("models/2_single_level_priors_no_gen.stan"))
```

Next, we'll compile the model. This allows us to check for errors.

```{r}
m2_upc <- stanc(file = "models/2_single_level_priors_no_gen.stan") # Check Stan file
m2_upc <- stan_model(stanc_ret = m2_upc) # Compile Stan code
```

67 seconds total.

```{r}
fit2_upc <- sampling(m2_upc, 
                warmup=400, 
                iter=4000, 
                seed=1, 
                data=data, 
                chains = 1,
                cores = getOption("mc.cores", 1L),
                verbose = TRUE)
rm(m2_upc)
```

```{r}
list_of_draws <- rstan::extract(fit1_upc)
print(names(list_of_draws))
print(fit1_upc, c("beta_0", "beta_1")) 
```

### Model 3- Single level model w/ everything

We'll add some generated quantities 

```{r}
writeLines(readLines("models/3_single_level_priors_gen.stan"))
```

Next, we'll compile the model. This allows us to check for errors.

```{r}
m3_upc <- stanc(file = "models/3_single_level_priors_gen.stan") # Check Stan file
m3_upc <- stan_model(stanc_ret = m3_upc) # Compile Stan code
```

1650 seconds total.

```{r}
fit3_upc <- sampling(m3_upc, 
                warmup=400, 
                iter=4000, 
                seed=1, 
                data=data, 
                chains = 1,
                cores = getOption("mc.cores", 1L),
                verbose = TRUE)
rm(m3_upc)
```

```{r}
list_of_draws <- rstan::extract(fit1_upc)
print(names(list_of_draws))
print(fit1_upc, c("beta_0", "beta_1")) 
```

```{r}
fit3_upc_loo <- loo(fit3_upc)
fit3_upc_loo
```

### Model Comparison (Save for when adding variables)

```{r}
fit3_upc_loo <- loo(fit3_upc)
# Compare log likelihoods
loo_compare(fit1_loo, fit2_loo, fit3_loo, fit1_upc_loo)
```

